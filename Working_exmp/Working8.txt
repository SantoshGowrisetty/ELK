#Sorting data
using sort we can add one or more sorts on specific fields, where in each sort can be reversed.
sort is defined per field level with field name '_score' to sort by score and optionally '_doc' to sort based on index order

GET /bankdata/_search
{
  "sort": [
    {"age": {"order": "asc"}},
    {"balance": {"order": "desc"}},
    "_score"],
    "query": {
      "term": {
        "age": {
          "value": "75"
        }
      }
    }
}

----
#sort using mode
GET /bankdata/_search
{
  "query": {
      "term": {
        "age": {
          "value": "75"
        }
      }
    },
  "sort": [
    {"balance": {"order": "asc",
    "mode": "avg"}}
  ]  
}

#aggregations
#using term aggregation 
#A multi-bucket value source based aggregation where buckets are dynamically built - one per unique value
GET /bankdata/_search
{
  "aggs": {
    "my-agg-name": {
      "terms": {
        "field": "balance"
      }
    }
  }
}

#Aggregation results are in the responseâ€™s aggregations object
GET /bankdata/_search
{
  "aggs": {
    "my-agg-name": {
      "terms": {
        "field": "marital"
      }
    }
  }
}

GET /bankdata/_mappings

PUT /bankdata/_mapping
{
  "properties": {
    "marital": {
      "type": "keyword"
    }
  }
}

PUT /bankdata/_mapping
{
  "properties": {
    "marital": {
       "type": "text",
          "fielddata": true
    }
  }
}

#changing the amount of data that is considered for aggregation
GET /bankdata/_search
{
  "query": {
    "range": {
      "balance": {
        "gte": 500,
        "lt": "3000"
      }
    }
  },
  "aggs": {
    "my-agg-name-new": {
      "terms": {
        "field": "marital"
      }
    }
  }
}

#to see only aggregation result, use size paramter
GET /bankdata/_search
{
  "query": {
    "range": {
      "balance": {
        "gte": 500,
        "lt": "3000"
      }
    }
  },
  "size": 0,
  "aggs": {
    "my-agg-name-new": {
      "terms": {
        "field": "marital"
      }
    }
  }
}

#using sub-aggregation
GET /bankdata/_search
{
  "aggs": {
    "my-agg-name": {
      "terms": {
        "field": "marital"
      },
      "aggs": {
        "my-sub-agg-name": {
          "avg": {
            "field": "balance"
          }
        }
      }
    }
  }
}

-----
#Managing state using policy
PUT /_plugins/_ism/policies/mgmt_policy?pretty
{
  "policy": {
    "description": "hot warm delete workflow",
    "default_state": "hot",
    "schema_version": 1,
    "states": [
      {
        "name": "hot",
        "actions": [
          {
            "rollover": {
              "min_index_age": "1d",
              "min_primary_shard_size": "30gb"
            }
          }
        ],
        "transitions": [
          {
            "state_name": "warm"
          }
        ]
      },
      {
        "name": "warm",
        "actions": [
          {
            "replica_count": {
              "number_of_replicas": 5
            }
          }
        ],
        "transitions": [
          {
            "state_name": "delete",
            "conditions": {
              "min_index_age": "1h"
            }
          }
        ]
      },
      {
        "name": "delete",
        "actions": [
          {
            "delete": {}
          }
        ]
      }
    ],
    "ism_template": {
      "index_patterns": ["testlog*"],
      "priority": 100
    }
  }
}

PUT _index_template/testlog
{
  "index_patterns": [
    "testlog*"
  ],
  "template": {
    "aliases": {
      "mylogs": {}
    },
    "settings": {
      "number_of_shards": 2,
      "number_of_replicas": 2
    },
    "mappings": {
      "properties": {
        "timestamp": {
          "type": "date",
          "format": "yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"
        },
        "value": {
          "type": "double"
        }
      }
    }
  }
}

PUT testlog

GET _cat/indices/testlog?v

GET _plugins/_ism/explain/testlog?pretty

GET testlog/_stats




